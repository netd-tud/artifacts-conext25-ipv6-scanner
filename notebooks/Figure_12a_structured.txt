# Filter für die gewünschte Source_Address
filtered_df = df4[df4['Source_Address'] == '2605:6400:10:6a8:bc7a:408:1ad:e7e6']

# Häufigste Einträge in der Spalte 'Session_ID_128' ermitteln
most_frequent_session = filtered_df['Session_ID_128'].value_counts()

# Ausgabe
print("Häufigste Einträge in 'Session_ID_128' für die gegebene Source_Address:")
print(most_frequent_session)




from matplotlib.patches import Rectangle
# DataFrame nach 'Timestamp' sortieren
# DataFrame nach 'Timestamp' sortieren
sorted_df3 = df4.sort_values(by='Timestamp')

# Filtern nach Source_Address und Tag
filtered_df_tenc_sort = sorted_df3[(sorted_df3['Source_Address'] == '2605:6400:10:6a8:bc7a:408:1ad:e7e6') & (sorted_df3['Session_ID_128'] == 44763)]

# Erstelle ein extra DataFrame mit nur der Spalte Dst_Address_full
ipv6_dest_2 = filtered_df_tenc_sort[['fullhex_destination_address']].copy()

# Zeilennummerierung neu setzen, damit Plot erstellt werden kann
ipv6_dest_2 = ipv6_dest_2.reset_index(drop=True)

# Konvertiere die Zieladressen in IPv6Address-Objekte

# Entferne Doppelpunkte aus den IPv6-Adressen
#ipv6_dest_2['fullhex_destination_address'] = ipv6_dest_2['fullhex_destination_address'].str.replace(':', '')

# Ersetze die ersten 8 Zeichen in allen Einträgen durch 'x'
#ipv6_dest_2['IPv6_Dest_Address'] = ipv6_dest_2['IPv6_Dest_Address'].apply(lambda x: 'x' * 8 + x[8:])

# Zeige die DataFrame nach der Änderung
#print(ipv6_dest_2.head())

# Bestimme die maximale Anzahl von Zeichen in den IPv6-Adressen
max_length = max(len(addr) for addr in ipv6_dest_2['fullhex_destination_address'])

palette = sns.color_palette("YlGnBu", 16)
# Erstelle eine leere Matrix basierend auf der maximalen Zeichenanzahl
heatmap_data = np.zeros((max_length, len(ipv6_dest_2)), dtype=int)


# Fülle die Matrix entsprechend den Zeichen in den IPv6-Adressen
for i, row in enumerate(ipv6_dest_2['fullhex_destination_address']):
    for j, char in enumerate(row):
        if char.isdigit():
            value = int(char)
        elif char.isalpha():
            value = ord(char.lower()) - ord('a') + 10
        else:
            continue  # Ignoriere andere Zeichen
        heatmap_data[j, i] = value

# Erstelle eine Heatmap mit seaborn und der Farbskala
plt.figure(figsize=(8 * 0.7, 3 * 0.7))
plt.rc("font", size=9)

heatmap = sns.heatmap(heatmap_data, cmap=palette, cbar=True, cbar_kws={'label': 'Hexadecimal character'})

plt.xlabel('Order of arrival [#]')
plt.ylabel('IPv6 address [nibble]')

# X-Achse anpassen
plt.xticks([])
# Y-Achse anpassen mit Intervallen
major_locator = MultipleLocator(4)  # Haupt-Intervall
minor_locator = MultipleLocator(2)  # Neben-Intervall

plt.gca().yaxis.set_major_locator(major_locator)
#plt.gca().yaxis.set_minor_locator(minor_locator)

y_ticks_positions = [3.5, 7.5, 11.5, 15.5, 19.5, 23.5, 27.5, 31.5]
y_ticks_labels = [4, 8, 12, 16, 20, 24, 28, 32]
plt.yticks(y_ticks_positions, labels=y_ticks_labels)

#plt.ylim(32, 8)

# Benutzerdefinierte Beschriftungen für die Farbpalette in der Legende festlegen
# Benutzerdefinierte Beschriftungen für die Farbpalette in der Legende festlegen
colorbar = heatmap.collections[0].colorbar
colorbar.set_ticks(np.linspace(0, 15, 16))  # Festlegen der Tickpositionen
#colorbar.set_ticks(np.linspace(0, 16)) 
colorbar.set_ticklabels(['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'])  # Festlegen der Beschriftungen

# Ändere die Größe der Farbpalette in der Legende (Verlängern der Farbbalken)
colorbar.ax.set_aspect(3)

for i in range(heatmap_data.shape[1]):  # Durchlaufe die Spalten
    for j in range(8):  # Nur die ersten 9 Zeilen einfärben
        heatmap.add_patch(Rectangle((i, j), 1, 1, fill=True, color='#D1D1D1'))

plt.text(0.5, 0.875, 'Telescope prefix', va='center', ha='center', fontsize=10, color='#000000', transform=plt.gca().transAxes)

# Plot speichern und anzeigen
plt.savefig(os.path.join("Diagramme", "ponynet_hex_longer.png"), bbox_inches="tight", dpi=300)
plt.show()